# Description

The following is a general research dump on a few different aspects of payments via the Lightning Network


## Lightning Invoices

At a high level the lightning network works by passing payments along a route of channels until it gets from sender to recipient. The payments are routed in an atomic way, meaning that, the payment either gets all the way to the recipient or it fails completely. This means that payments can't get stuck or stolen at any point in the routing from sender to recipient.

### The Standard Invoice

Payments are made via invoices that are generated by the recipient and sent to the sender via some out of band method (QR code, text message etc.).

_[Note: The following describes the technical bits relevant [for routing](https://github.com/lnbook/lnbook/blob/adbd2efbad97323c587fb3c6efee7ebd03392993/routing.asciidoc). We should probably include notes on the other elements of an invoice as well e.g. amount, recipient node id, description etc.]_

Invoices are made up of a few different pieces of information, but the two critical bits that we are usually concerned with are:
1. The payment hash, and
1. The payment preimage

#### Payment hash
Think of this as a single blob that acts as a fingerprint that secures the invoice. It is not related to the rest of the invoice contents in any way and a single payment hash can optionally be used to make multiple invoices (see **Hodl invoices** below). For a standard payment, the payment hash is included as part if an invoice created by the recipient and the invoice is given to the sender for payment.

Payment hashes are created by first randomly selecting some secret (preimage) and then hashing this to the payment hash.

#### Payment preimage
Think of this as the receipt that is provided on successful delivery of a payment. This receipt is held secretly by the recipient and only revealed on receipt of the payment that comes in across the network.

The way it is revealed is by passing the preimage back up the route to the nodes who forwarded the payment down. This preimage allows each node to trustlessly collect the fees for their part of the route, and the preimage is passed all the way back up to the sender. The sender can confirm that a given preimage is the correct one for a payment by calculating the hash and comparing to the payment hash included in the invoice.

_**Important:** if this secret is revealed before the payment is received, other participants in the network involved in routing this particular payment can steal the funds (note: confim this) en route before it gets to its destination. This could be done by passing the receipt (preimage) back up the chain without sending the payment forward to the recipient._

#### Expiry time
This is effectively a time limit past which the invoice becomes invalid.

(Research how this is enforced. So far I'm only finding that the recipient discards the preimage, but this doesn't make sense in cases where the recipient isn't the one generating th preimage as with hodl invoices)


--

**_Links:_**
- _Technical breakdown of a Lightning Invoice: https://medium.com/suredbits/lightning-101-what-is-a-lightning-invoice-d527db1a77e6_
- _Required fields for a Lightning Invoice: https://btcmanager.com/brief-guide-how-create-lightning-network-invoices/_

### The HODL Invoice

At a high level, a `hodl invoice` is an invoice that is held by the recipient but not settled right away. A `hodl invoice` can be resolved in two ways:
1. The payment is **_settled_** when the recipient releases the preimage (to the payment route)
1. The payment is **_canceled_** if the recipient does not release the preimage and the invoice expires

A `hodl invoice` works in the exact way that a standard invoice does except that, when the recipient receives the payment on a given route they do not immediately/automatically return the `preimage` back. _As a reminder, a successful payment is a 2-part process consisting of sending a payment for a given invoice along a Lightning Network route from sender to recipient and receiving the secret (preimage) for the payment back up to the route._

With a `hodl invoice` there is also an addiitonal option where the recipient **_does not_** have to be the same person _creating the payment hash for a given invoice_ they will generate (as is usually the case). They can also receive a payment hash from another party to create an invoice again where that other party would be the one that will hold the secret (preimage) for the hash until some condition is met and the secret is revealed which allows the invoice to be successfully settled.

#### Scenarios ([source](https://wiki.ion.radar.tech/tech/research/hodl-invoice) & [more examples](https://github.com/lightningnetwork/lnd/pull/2022))

To help expose some of how a hodl invoice works, the following are a set of hypothetical real-world scenarios that are created by using different combinations of the elements of a hodl invoice in different ways.

The two elements that will be varying are:
- **who creates** the preimage and generates the payment hash from it for a given invoice
- **how** the preimage **gets revealed** to the final recipient/s for settlement

**Simple delay by recipient**

1. **No reveal required** (because recipient creates the preimage secret)

    This type of hodl invoice can be used to manage merchant returns for e.g where the merchant can hold the invoice for a certain return period and only settle it after the return period expires. If a return is made, the merchant simply does not settle the invoice and the funds are effectively returned to the customer.

    It can also be used in the opposite way where a recipient _does not_ settle the invoice if some condition is met. In this scenario, the hodl invoice acts as a fidelity bond of sorts for the performance of some service or action, and failure to perform that service/action leads the the recipient settling the invoice (cashing the bond)


_(All other examples below, trust not to reveal secret preimage to any other route participants)_


**Simple delay by the sender**

1. **Secret revealed out-of-band by sender**
    e.g. customer pays the invoice but holds the secret until delivery of service when it is revealed to the merchant allowing them to settle the paid invoice

1. **Secret revealed via on-chain transaction**
    e.g. submarine swap where sender must necessarily reveal the preimage when sweeping an on-chain htlc and recipient can use revealed preimage to settle invoice

    _caveat: preimage is revealed before transaction is mined. If high enough fee isn't used, recipient could potentially double-spend UTXOs involved in HTLC before HTLC can be mined_


**Chained delay by sender**

1. **Secret revealed out-of-band by sender, secret revealed via settlement to chain participants**

    In this scenario, the sender (customer) can generate a single preimage and share the resulting payment hash to multiple parties for them to make invoices from. This allows for a chained settlement of sorts where settlement of an invoice at the tip of the chain reveals he preimage progressively to other payment chain participants hwho can in turn settle their own invoices and reveal the preimage to other participants down the chain.

    An example:

    - Customer creates payment hash and gives to merchant with the caveat that they will only reveal the image to a courier on delivery of the items

    - Merchant finds a courier and shares the payment hash with them to create a service invoice that the merchant pays to the courier. The courier can only settle this invoice by successfully delivering items to the customer and receiving the preimage from them

    - On successful delivery, the courier receives the preimage from the customer (an out-of-band reveal) and settles the invoice the merchant paid them. Once this invoice is settled the preimage is naturally revealed to the merchant (revealed by invoice settlement) who can then use it to settle the invoice the customer in turn had originally paid them with

    _**Caveat:** if a path participant sits on two routes, there's a risk they can take the revealed preimage from payment of one invoice and collect settlement on the second invoice before the recipient is able to settle their hodl invoice_

#### Limitations

- Limit of 483 in-flight invoices can be routed at any given time by a node ([something about on-chain transaction size limit?](https://bitcoin.stackexchange.com/a/91169))

    This is distinct from "open invoices" and only refers to invoices where the payment was started but is still incomplete, as can happen with hodl invoices



### Keysend (no invoice)

The `keysend` feature is a way for a sender to send a payment to a given recipient over the Lightning Network **without first having an invoice** from the recipient to send against ([docs](https://lightning.readthedocs.io/lightning-keysend.7.html)).

The way this works is the sender first needs the **destination node id (node's public key)** for the recipient's Lightning Network node. The sender then creates a preimage and uses it to construct a keysend payment that it then forwards along an appropriate route to the recipient.

When the recipient receives the keysend payment, they would decode the payment and extract the preimage to accept the payment (resolve the HTLC). The recipient would also create an ad-hoc invoice on their end that corresponds to the payment and store it in their local invoice registry.

The recipient would usually have no way of knowing who sent the keysend payment unless the sender somehow makes this explicitly known.

This is a feature that is currently fully supported in:
- `lnd` ([PR #3795](https://github.com/lightningnetwork/lnd/pull/3795))
- `eclair` ([PR #1485](https://github.com/ACINQ/eclair/pull/1485))
- `c-lightning` ([PR #3792](https://github.com/ElementsProject/lightning/pull/3792))

_Note: Unlike when sending against a lightning invoice, if the same keysend is attempted multiple times then multiple fund transfers occur._

_`keysend` used to be previously called `sphinx send` as a reference to the [sphinx packets](https://wiki.ion.radar.tech/tech/lightning/sphinx-packet) that the Lightning Network uses to onion route packets across the network._

#### Useful "additional data" mechanisms & applications

 - There is a [`--data` flag](https://api.lightning.community/#sendpayment) for sending along data as well (needs `record=hexvalue`)
    - This can potentially be used for including things like custom messages or sender info (e.g. see Whatsat's [usage of custom records](https://github.com/joostjager/whatsat/tree/b3759020e913727ef2f9661b3463a5035b6887a6#protocol))

- [Custom tlv data records](https://github.com/lightningnetwork/lnd/pull/3742) + keysend open up some interesting possibilities (see this [tlvshop](https://twitter.com/joostjgr/status/1234896447038017537) example)


#### Common criticisms

**No cryptographic proof of payment for the sender**
A common concern you would hear is that the sender does not have in hand a signed invoice that matches to the preimage they would hold for the payment as there would be in a standard transaction. This means that there is technically nothing proving that the preimage was given to the recipient and settled along a route back to the sender (_see Rusty Russell's response, [tweet](https://twitter.com/rusty_twit/status/1346582657363181568) | [img](./assets/img/lightning-payments-keysend-rusty.png)_).

Not everyone agrees with this perspective though since not everyone puts the same level of importance on having this cryptographic linkage for a fulfilled payment.
- Conner Fromknecht from Lightning Labs ([tweet](https://twitter.com/bitconner/status/1349178391073746944) | [img](./assets/img/lightning-payments-keysend-conner.png))
- Alex Bosworth from Lightning Labs ([img](./assets/img/lightning-payments-keysend-alex.png))


### Lightning Offers (invoices on demand)

Covered by potentially BOLT12, still in development...
- [Announcement on `lightning-dev` mailing list](https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-November/002276.html)
- [WIP PR on Github](https://github.com/lightningnetwork/lightning-rfc/pull/798)


### Multi-part Payments

Methods for sending multiple LN payments (HTLCs) to make up a single logical payment. The reasoning behind this is to allow for splitting a payment across multiple routes. A person could want to do this for a number of reasons including:
- to get around channel size & balance limitations
- to improve routing fee efficiency
- to improve privacy (?, more applies to AMP)

#### Base AMP
An implementation of multi-part payments that has [already been accepted](https://github.com/lightningnetwork/lightning-rfc/pull/643) into BOLT-04 of the Lightning Network Spec, where:

- the recipient provides an invoice

- the sender creates a number of HTLCs and sets the same single payment hash in all HTLCs

- the recipient only settles all HTLCs when they receive all HTLCs for a given invoice

    - a discretionary decision; it is in the recipient's interest to not settle HTLCs until all have been received since settling any one of the HTLCs could serve as proof of all HTLCs being settled since they all use the same preimage. Even worse, this could also allow nodes along the route paths to steal other HTLCs before forwarding them to the final recipient if they have access to the revealed preimage from a prior HTLC

    - indicated by HTLC amounts adding up to the `total_msat` amount for the invoice

    - individual HTLCs  are treated as with HODL invoices where the HTLCs aren't immediately settled

Implemented in:
- `lnd` ([PR #3967](https://github.com/lightningnetwork/lnd/pull/3967), [blogpost](https://lightning.engineering/posts/2020-05-07-mpp/))
- `c-lightning` ([PR #3809](https://github.com/ElementsProject/lightning/pull/3809))
- `eclair` ([PR #1153](https://github.com/ACINQ/eclair/pull/1153))

#### Moon AMP
An implementation that seeks to improve on **Base AMP** by improving the privacy and atomicity guarantees of a given multi-path payment. The main ways it differs from Base AMP are:

- the sender creates preimages to be attached to HTLCs and uses a different preimage for each HTLC created (improves privacy); this is as opposed to Base AMP where the recipient creates a single preimage and the sender uses the same corresponding payment hash in all HTLCs that would make up the entire payment, i.e. non-interactive where the sender does not need to co-ordinate with the recipient to send a payment, but where explicit invoicing can be supported later on

- allows for more detailed spontaneous payments that can potentially replace `keysend` as a robust alternative

- allows for more robust atomicity by defining a number of fail conditions that effectively inhibit HTLC settlement until a full set of valid HTLCs is received for a given payment


Described by:
- [mailing list description](https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-February/000993.html)
- [Lightning Spec BOLT-04 PR](https://github.com/lightningnetwork/lightning-rfc/pull/658)


### Submarine Swap

Funds that are locked into a Lightning channel are usually limited to being transferrable solely across the Lightning Network. They can be sent back and forth on a given channel, but cannot come back on-chain unless the channel is closed.

This presents a few challenging scenarios:
- managing channel balancing (available liquidity)
- sending transactions across the boundaries of on-chain and off-chain

Submarine swaps have emerged as a way to bridge these deficiencies by allowing persons to send funds from an on-chain address directly into an open Lightning channel and vice versa.

#### Mechanism

There are a few variants to how the swaps actually work but the overall mechanism is that a Lightning invoice is generated by one of the parties and the payment hash of that invoice is included in an on-chain transaction. This is done in such a way that payment of the Lightning invoice reveals the preimage of the hash which allows the other party to spend the on-chain transaction and collect funds.

Some examples of this mechanism include:
- [Boltz exchange](https://medium.com/boltzhq/submarine-swaps-c509ce0fb1db)
- [Lightning Loop](https://lightning.engineering/loop/)
- [using HODL Invoices](https://wiki.ion.radar.tech/tech/research/hodl-invoice#submarine-swap-variation)

#### Scenarios

- **Channel balancing**

    In Lightning Network design there is a popular analogy with marbles in a tube that is used to describe the problem of being able to send/receive across a channel and the limitations that come from not having balanced channels.

    [Insert explainer here]

    Channels can be rebalanced if they can somehow receive funds or route funds in the opposite direction to the desired direction that the user would like funds to flow in. One way of doing this is reallocating balances from other channels the user owns, but this still doesn't impact the overall send/receive liquidity that a node is capable of at a given point in time.

    By being able to effectively "teleport" funds from an on-chain address into a Lightning channel or set of channels and vice versa, a user is able to rebalance the overall state of their node by using on-chain funds.

- **On/Off-chain payments**

    Using this mechanism, merchants can also directly pay on-chain invoices with Lightning funds and vice versa by using some submarine swap service or client in the middle.

#### Novel Scenarios

- **Handling toxic change**

    A potential application of this mechanism could also be the handling of toxic UTXOs from processes like mixing and coinjoins ([example here](https://github.com/chaincase-app/chaincase/discussions/150)). The change can be sent to a submarine swap service and funds received into some channel so that the funds are effectively teleported away from those UTXOs in a ^fairly unlinkable way.

    ^ - _the submarine swap provider would still theoretically be able to make this linkage_
